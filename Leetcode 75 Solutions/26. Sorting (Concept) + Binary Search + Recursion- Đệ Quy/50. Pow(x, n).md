# Leetcode 50. Pow(x, n) 
Topic: Sorting (Concept) + Binary Search + Recursion- Đệ Quy

Approach:
- Handle Negative Exponents: If $n < 0$, convert the problem to $(1/x)^{-n}$ to handle the reciprocal and make the exponent positive.
- Base Case: If $n = 0$, return $1$, as any number (except zero) raised to the power of 0 is 1.
- Divide and Conquer (Binary Exponentiation):
  - If $n$ is even, reduce the problem size by squaring the base and halving the exponent: $x^n = (x^2)^{n/2}$.
  - If $n$ is odd, apply the same logic but multiply by an extra $x$ to account for the remainder: $x^n = x \cdot (x^2)^{\lfloor n/2 \rfloor}$.
- This recursive structure ensures that the number of multiplications is reduced from $n$ to $\log n$.

Time Complexity:
- $O(\log n)$: In each recursive step, the exponent $n$ is divided by 2. This results in a logarithmic number of calls relative to the size of $n$.
Space Complexity:
- $O(\log n)$: This is the space required for the recursive call stack. Since the depth of the recursion tree is $\log n$, the system stores that many functional frames in memory.
  

```
class Solution(object):
    def myPow(self, x, n):
        # For negative powers: x^(-n) = (1/x)^n	
        if n < 0:
            x = 1 / x
            n = -n

        # Fast exponentiation
        if n == 0:
            return 1

    # If exponent is even: x^n = (x^2)^(n/2)
        if n % 2 == 0:
            return self.myPow(x * x, n // 2)
            # If exponent is odd: x^n = x * (x^2)^(n//2)
        else:
            return self.myPow(x * x, n // 2) * x
```

